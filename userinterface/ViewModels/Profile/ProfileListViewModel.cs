using System.Collections.ObjectModel;
using System.Windows.Input;
using userinterface.Commands;
using userspace_backend;
using BE = userspace_backend.Model;
using CommunityToolkit.Mvvm.ComponentModel;
using System;
using System.Linq;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;
using System.Collections.Concurrent;

namespace userinterface.ViewModels.Profile
{
    public partial class ProfileListViewModel : ViewModelBase
    {
        private const int MaxProfileAttempts = 10;
        private readonly BE.ProfilesModel profilesModel;
        private readonly SemaphoreSlim operationQueue = new(1, 1);
        private readonly ConcurrentQueue<Func<Task>> pendingOperations = new();
        private volatile bool isProcessingQueue = false;
        
        [ObservableProperty]
        private BE.ProfileModel selectedProfile;
        
        public event Action<BE.ProfileModel> SelectedProfileChanged;

        public ProfileListViewModel(BackEnd backEnd)
        {
            profilesModel = backEnd?.Profiles ?? throw new System.ArgumentNullException(nameof(backEnd));
            AddProfileCommand = new RelayCommand(TryAddProfile);
        }

        public ObservableCollection<BE.ProfileModel> Profiles => profilesModel.Profiles;
        public ICommand AddProfileCommand { get; }

        public void TryAddProfile()
        {
            // Queue the operation to prevent overlapping
            pendingOperations.Enqueue(async () => await TryAddProfileAsync());
            _ = ProcessOperationQueue();
        }
        
        private async Task TryAddProfileAsync()
        {
            var startTime = DateTime.Now;
            Debug.WriteLine($"[PROFILE_QUEUE] Starting profile add operation at: {startTime:HH:mm:ss.fff}");
            
            var profileName = GenerateProfileName();
            if (TryAddProfileWithName(profileName))
            {
                var backendAddTime = DateTime.Now;
                Debug.WriteLine($"[PROFILE_QUEUE] Profile added to backend at: {backendAddTime:HH:mm:ss.fff}");
                
                // Move the newly added profile to the optimal position
                MoveNewProfileToOptimalPosition(profileName);
                
                var reorderTime = DateTime.Now;
                Debug.WriteLine($"[PROFILE_QUEUE] Profile reordered at: {reorderTime:HH:mm:ss.fff}");
                
                // Wait for any animations to complete before allowing next operation
                await WaitForAnimationsToComplete();
                
                var completionTime = DateTime.Now;
                Debug.WriteLine($"[PROFILE_QUEUE] Profile add operation completed at: {completionTime:HH:mm:ss.fff}");
            }
        }
        
        private void MoveNewProfileToOptimalPosition(string profileName)
        {
            // Find the newly added profile (should be at the end)
            var newProfile = Profiles.FirstOrDefault(p => p.Name.ModelValue == profileName);
            if (newProfile == null) return;
            
            // Find the optimal insertion position - before other "Profile X" entries but after custom names
            int insertPosition = FindOptimalInsertPosition();
            
            // Remove from current position (end) and insert at optimal position
            int currentIndex = Profiles.IndexOf(newProfile);
            if (currentIndex >= 0 && currentIndex != insertPosition)
            {
                Profiles.RemoveAt(currentIndex);
                // Adjust insert position if we removed from before it
                if (currentIndex < insertPosition) insertPosition--;
                Profiles.Insert(insertPosition, newProfile);
            }
        }
        
        private int FindOptimalInsertPosition()
        {
            // Find the first "Profile X" entry (auto-generated name) after the Default profile
            for (int i = 1; i < Profiles.Count; i++) // Start at 1 to skip Default profile
            {
                var profile = Profiles[i];
                if (IsAutoGeneratedProfileName(profile.Name.ModelValue))
                {
                    return i; // Insert before the first auto-generated profile
                }
            }
            
            // If no auto-generated profiles found, insert at the end
            return Profiles.Count;
        }
        
        private static bool IsAutoGeneratedProfileName(string name)
        {
            return System.Text.RegularExpressions.Regex.IsMatch(name, @"^Profile \d+$");
        }

        public bool TryAddProfileAtPosition(int position)
        {
            var profileName = GenerateProfileName();
            if (!profilesModel.TryAddNewDefaultProfile(profileName)) return false;
            
            // Move the newly added profile to the specified position
            var newProfile = profilesModel.Profiles[^1]; // Get the last added profile
            profilesModel.Profiles.RemoveAt(profilesModel.Profiles.Count - 1);
            
            // Ensure position is within bounds
            int clampedPosition = Math.Max(1, Math.Min(position, profilesModel.Profiles.Count));
            profilesModel.Profiles.Insert(clampedPosition, newProfile);
            
            return true;
        }
        
        private bool TryAddProfileWithName(string profileName)
        {
            return !string.IsNullOrEmpty(profileName) && profilesModel.TryAddNewDefaultProfile(profileName);
        }
        
        private string GenerateProfileName()
        {
            for (int i = 1; i <= MaxProfileAttempts; i++)
            {
                string name = $"Profile {i}";
                if (!profilesModel.TryGetProfile(name, out _))
                {
                    return name;
                }
            }
            return string.Empty;
        }

        private async Task ProcessOperationQueue()
        {
            if (isProcessingQueue) return;
            
            isProcessingQueue = true;
            
            try
            {
                while (pendingOperations.TryDequeue(out var operation))
                {
                    await operationQueue.WaitAsync();
                    try
                    {
                        await operation();
                    }
                    finally
                    {
                        operationQueue.Release();
                    }
                }
            }
            finally
            {
                isProcessingQueue = false;
            }
        }
        
        private async Task WaitForAnimationsToComplete()
        {
            // Wait for the UI update and animations to complete
            // Based on the View's animation settings:
            // - Animation duration: 300ms 
            // - Stagger delay: up to 3 * 20ms = 60ms
            // - Safety margin: 100ms
            // Total conservative wait: 460ms
            
            int baseAnimationTime = 300;  // Animation duration from View
            int maxStaggerDelay = 60;      // Max stagger delay (3 profiles * 20ms)
            int safetyMargin = 100;        // Safety margin for UI updates
            int totalWaitTime = baseAnimationTime + maxStaggerDelay + safetyMargin;
            
            Debug.WriteLine($"[PROFILE_QUEUE] Waiting {totalWaitTime}ms for animations to complete");
            await Task.Delay(totalWaitTime);
            Debug.WriteLine($"[PROFILE_QUEUE] Animation wait completed");
        }
        

        public bool RemoveProfile(BE.ProfileModel profile) => profile != null && profilesModel.RemoveProfile(profile);
        
        partial void OnSelectedProfileChanged(BE.ProfileModel value)
        {
            SelectedProfileChanged?.Invoke(value);
        }
        
        public void Dispose()
        {
            operationQueue?.Dispose();
        }
    }
}