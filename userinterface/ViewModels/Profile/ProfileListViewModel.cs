using System.Collections.ObjectModel;
using System.Windows.Input;
using userinterface.Commands;
using userspace_backend;
using BE = userspace_backend.Model;
using CommunityToolkit.Mvvm.ComponentModel;
using System;
using System.Linq;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;
using System.Collections.Concurrent;

namespace userinterface.ViewModels.Profile
{
    public partial class ProfileListViewModel : ViewModelBase
    {
        private const int MaxProfileAttempts = 10;
        private readonly BE.ProfilesModel profilesModel;
        private readonly SemaphoreSlim operationQueue = new(1, 1);
        private readonly ConcurrentQueue<Func<Task>> pendingOperations = new();
        private volatile bool isProcessingQueue = false;
        private Views.Profile.ProfileListView profileListView;
        
        [ObservableProperty]
        private BE.ProfileModel selectedProfile;
        
        public event Action<BE.ProfileModel> SelectedProfileChanged;

        public ProfileListViewModel(BackEnd backEnd)
        {
            profilesModel = backEnd?.Profiles ?? throw new System.ArgumentNullException(nameof(backEnd));
            AddProfileCommand = new RelayCommand(TryAddProfile);
        }

        public ObservableCollection<BE.ProfileModel> Profiles => profilesModel.Profiles;
        public ICommand AddProfileCommand { get; }
        
        public void SetView(Views.Profile.ProfileListView view)
        {
            profileListView = view;
        }

        public void TryAddProfile()
        {
            // Queue the operation to prevent overlapping
            pendingOperations.Enqueue(async () => await TryAddProfileAsync());
            _ = ProcessOperationQueue();
        }
        
        private async Task TryAddProfileAsync()
        {
            var startTime = DateTime.Now;
            
            var profileName = GenerateProfileName();
            if (TryAddProfileWithName(profileName))
            {
                var backendAddTime = DateTime.Now;        
                
                MoveNewProfileToOptimalPosition(profileName);
                
                var reorderTime = DateTime.Now;
                
                // Wait for any animations to complete before allowing next operation
                await WaitForAnimationsToComplete();
                
                var completionTime = DateTime.Now;
            }
        }
        
        private void MoveNewProfileToOptimalPosition(string profileName)
        {
            // Find the newly added profile (should be at the end)
            var newProfile = Profiles.FirstOrDefault(p => p.Name.ModelValue == profileName);
            if (newProfile == null) return;
            
            // Find the optimal insertion position - before other "Profile X" entries but after custom names
            int insertPosition = FindOptimalInsertPosition();
            
            int currentIndex = Profiles.IndexOf(newProfile);
            if (currentIndex >= 0 && currentIndex != insertPosition)
            {
                Profiles.RemoveAt(currentIndex);
                // Adjust insert position if we removed from before it
                if (currentIndex < insertPosition) insertPosition--;
                Profiles.Insert(insertPosition, newProfile);
            }
        }
        
        private int FindOptimalInsertPosition()
        {
            // Find the first "Profile X" entry (auto-generated name) after the Default profile
            for (int i = 1; i < Profiles.Count; i++) // Start at 1 to skip Default profile
            {
                var profile = Profiles[i];
                if (IsAutoGeneratedProfileName(profile.Name.ModelValue))
                {
                    return i; // Insert before the first auto-generated profile
                }
            }
            
            return Profiles.Count;
        }
        
        private static bool IsAutoGeneratedProfileName(string name)
        {
            return System.Text.RegularExpressions.Regex.IsMatch(name, @"^Profile \d+$");
        }

        public bool TryAddProfileAtPosition(int position)
        {
            var profileName = GenerateProfileName();
            if (!profilesModel.TryAddNewDefaultProfile(profileName)) return false;
            
            // Move the newly added profile to the specified position
            var newProfile = profilesModel.Profiles[^1];
            profilesModel.Profiles.RemoveAt(profilesModel.Profiles.Count - 1);
            
            // Ensure position is within bounds
            int clampedPosition = Math.Max(1, Math.Min(position, profilesModel.Profiles.Count));
            profilesModel.Profiles.Insert(clampedPosition, newProfile);
            
            return true;
        }
        
        private bool TryAddProfileWithName(string profileName)
        {
            return !string.IsNullOrEmpty(profileName) && profilesModel.TryAddNewDefaultProfile(profileName);
        }
        
        private string GenerateProfileName()
        {
            for (int i = 1; i <= MaxProfileAttempts; i++)
            {
                string name = $"Profile {i}";
                if (!profilesModel.TryGetProfile(name, out _))
                {
                    return name;
                }
            }
            return string.Empty;
        }

        private async Task ProcessOperationQueue()
        {
            if (isProcessingQueue) return;
            
            isProcessingQueue = true;
            
            try
            {
                while (pendingOperations.TryDequeue(out var operation))
                {
                    await operationQueue.WaitAsync();
                    try
                    {
                        await operation();
                    }
                    finally
                    {
                        operationQueue.Release();
                    }
                }
            }
            finally
            {
                isProcessingQueue = false;
            }
        }
        
        private async Task WaitForAnimationsToComplete()
        {
            if (profileListView != null)
            {
                while (profileListView.AreAnimationsActive)
                {
                    await Task.Delay(50); // Check every 50ms
                }
                
                await Task.Delay(50);
            }
            else
            {
                await Task.Delay(400);
            }
        }
        

        public bool RemoveProfile(BE.ProfileModel profile) => profile != null && profilesModel.RemoveProfile(profile);
        
        partial void OnSelectedProfileChanged(BE.ProfileModel value)
        {
            SelectedProfileChanged?.Invoke(value);
        }
        
        public void Dispose()
        {
            operationQueue?.Dispose();
        }
    }
}